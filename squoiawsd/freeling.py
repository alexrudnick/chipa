# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_freeling', [dirname(__file__)])
        except ImportError:
            import _freeling
            return _freeling
        if fp is not None:
            try:
                _mod = imp.load_module('_freeling', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _freeling = swig_import_helper()
    del swig_import_helper
else:
    import _freeling
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _freeling.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self) -> "PyObject *" : return _freeling.SwigPyIterator_value(self)
    def incr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _freeling.SwigPyIterator_incr(self, n)
    def decr(self, n : 'size_t'=1) -> "swig::SwigPyIterator *" : return _freeling.SwigPyIterator_decr(self, n)
    def distance(self, *args) -> "ptrdiff_t" : return _freeling.SwigPyIterator_distance(self, *args)
    def equal(self, *args) -> "bool" : return _freeling.SwigPyIterator_equal(self, *args)
    def copy(self) -> "swig::SwigPyIterator *" : return _freeling.SwigPyIterator_copy(self)
    def next(self) -> "PyObject *" : return _freeling.SwigPyIterator_next(self)
    def __next__(self) -> "PyObject *" : return _freeling.SwigPyIterator___next__(self)
    def previous(self) -> "PyObject *" : return _freeling.SwigPyIterator_previous(self)
    def advance(self, *args) -> "swig::SwigPyIterator *" : return _freeling.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args) -> "bool" : return _freeling.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _freeling.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args) -> "swig::SwigPyIterator &" : return _freeling.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args) -> "swig::SwigPyIterator &" : return _freeling.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args) -> "swig::SwigPyIterator *" : return _freeling.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args) -> "ptrdiff_t" : return _freeling.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _freeling.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class VectorWord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorWord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorWord, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorWord_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorWord___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorWord___bool__(self)
    def __len__(self) -> "std::vector< freeling::word >::size_type" : return _freeling.VectorWord___len__(self)
    def pop(self) -> "std::vector< freeling::word >::value_type" : return _freeling.VectorWord_pop(self)
    def __getslice__(self, *args) -> "std::vector< freeling::word,std::allocator< freeling::word > > *" : return _freeling.VectorWord___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorWord___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorWord___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorWord___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< freeling::word >::value_type const &" : return _freeling.VectorWord___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorWord___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorWord_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorWord_empty(self)
    def size(self) -> "std::vector< freeling::word >::size_type" : return _freeling.VectorWord_size(self)
    def clear(self) -> "void" : return _freeling.VectorWord_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorWord_swap(self, *args)
    def get_allocator(self) -> "std::vector< freeling::word >::allocator_type" : return _freeling.VectorWord_get_allocator(self)
    def begin(self) -> "std::vector< freeling::word >::iterator" : return _freeling.VectorWord_begin(self)
    def end(self) -> "std::vector< freeling::word >::iterator" : return _freeling.VectorWord_end(self)
    def rbegin(self) -> "std::vector< freeling::word >::reverse_iterator" : return _freeling.VectorWord_rbegin(self)
    def rend(self) -> "std::vector< freeling::word >::reverse_iterator" : return _freeling.VectorWord_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorWord_pop_back(self)
    def erase(self, *args) -> "std::vector< freeling::word >::iterator" : return _freeling.VectorWord_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorWord(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorWord_push_back(self, *args)
    def front(self) -> "std::vector< freeling::word >::value_type const &" : return _freeling.VectorWord_front(self)
    def back(self) -> "std::vector< freeling::word >::value_type const &" : return _freeling.VectorWord_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorWord_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorWord_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorWord_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorWord_reserve(self, *args)
    def capacity(self) -> "std::vector< freeling::word >::size_type" : return _freeling.VectorWord_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorWord
    __del__ = lambda self : None;
VectorWord_swigregister = _freeling.VectorWord_swigregister
VectorWord_swigregister(VectorWord)

class ListWord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListWord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListWord, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListWord_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListWord___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListWord___bool__(self)
    def __len__(self) -> "std::list< freeling::word >::size_type" : return _freeling.ListWord___len__(self)
    def pop(self) -> "std::list< freeling::word >::value_type" : return _freeling.ListWord_pop(self)
    def __getslice__(self, *args) -> "std::list< freeling::word,std::allocator< freeling::word > > *" : return _freeling.ListWord___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListWord___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListWord___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListWord___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< freeling::word >::value_type const &" : return _freeling.ListWord___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListWord___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListWord_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListWord_empty(self)
    def size(self) -> "std::list< freeling::word >::size_type" : return _freeling.ListWord_size(self)
    def clear(self) -> "void" : return _freeling.ListWord_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListWord_swap(self, *args)
    def get_allocator(self) -> "std::list< freeling::word >::allocator_type" : return _freeling.ListWord_get_allocator(self)
    def begin(self) -> "std::list< freeling::word >::iterator" : return _freeling.ListWord_begin(self)
    def end(self) -> "std::list< freeling::word >::iterator" : return _freeling.ListWord_end(self)
    def rbegin(self) -> "std::list< freeling::word >::reverse_iterator" : return _freeling.ListWord_rbegin(self)
    def rend(self) -> "std::list< freeling::word >::reverse_iterator" : return _freeling.ListWord_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListWord_pop_back(self)
    def erase(self, *args) -> "std::list< freeling::word >::iterator" : return _freeling.ListWord_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListWord(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListWord_push_back(self, *args)
    def front(self) -> "std::list< freeling::word >::value_type const &" : return _freeling.ListWord_front(self)
    def back(self) -> "std::list< freeling::word >::value_type const &" : return _freeling.ListWord_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListWord_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListWord_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListWord_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListWord_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListWord_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListWord_reverse(self)
    __swig_destroy__ = _freeling.delete_ListWord
    __del__ = lambda self : None;
ListWord_swigregister = _freeling.ListWord_swigregister
ListWord_swigregister(ListWord)

class ListAnalysis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListAnalysis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListAnalysis, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListAnalysis_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListAnalysis___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListAnalysis___bool__(self)
    def __len__(self) -> "std::list< freeling::analysis >::size_type" : return _freeling.ListAnalysis___len__(self)
    def pop(self) -> "std::list< freeling::analysis >::value_type" : return _freeling.ListAnalysis_pop(self)
    def __getslice__(self, *args) -> "std::list< freeling::analysis,std::allocator< freeling::analysis > > *" : return _freeling.ListAnalysis___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListAnalysis___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListAnalysis___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListAnalysis___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< freeling::analysis >::value_type const &" : return _freeling.ListAnalysis___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListAnalysis___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListAnalysis_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListAnalysis_empty(self)
    def size(self) -> "std::list< freeling::analysis >::size_type" : return _freeling.ListAnalysis_size(self)
    def clear(self) -> "void" : return _freeling.ListAnalysis_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListAnalysis_swap(self, *args)
    def get_allocator(self) -> "std::list< freeling::analysis >::allocator_type" : return _freeling.ListAnalysis_get_allocator(self)
    def begin(self) -> "std::list< freeling::analysis >::iterator" : return _freeling.ListAnalysis_begin(self)
    def end(self) -> "std::list< freeling::analysis >::iterator" : return _freeling.ListAnalysis_end(self)
    def rbegin(self) -> "std::list< freeling::analysis >::reverse_iterator" : return _freeling.ListAnalysis_rbegin(self)
    def rend(self) -> "std::list< freeling::analysis >::reverse_iterator" : return _freeling.ListAnalysis_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListAnalysis_pop_back(self)
    def erase(self, *args) -> "std::list< freeling::analysis >::iterator" : return _freeling.ListAnalysis_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListAnalysis(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListAnalysis_push_back(self, *args)
    def front(self) -> "std::list< freeling::analysis >::value_type const &" : return _freeling.ListAnalysis_front(self)
    def back(self) -> "std::list< freeling::analysis >::value_type const &" : return _freeling.ListAnalysis_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListAnalysis_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListAnalysis_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListAnalysis_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListAnalysis_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListAnalysis_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListAnalysis_reverse(self)
    __swig_destroy__ = _freeling.delete_ListAnalysis
    __del__ = lambda self : None;
ListAnalysis_swigregister = _freeling.ListAnalysis_swigregister
ListAnalysis_swigregister(ListAnalysis)

class ListSentence(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListSentence, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListSentence, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListSentence_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListSentence___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListSentence___bool__(self)
    def __len__(self) -> "std::list< freeling::sentence >::size_type" : return _freeling.ListSentence___len__(self)
    def pop(self) -> "std::list< freeling::sentence >::value_type" : return _freeling.ListSentence_pop(self)
    def __getslice__(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > > *" : return _freeling.ListSentence___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListSentence___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListSentence___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListSentence___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< freeling::sentence >::value_type const &" : return _freeling.ListSentence___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListSentence___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListSentence_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListSentence_empty(self)
    def size(self) -> "std::list< freeling::sentence >::size_type" : return _freeling.ListSentence_size(self)
    def clear(self) -> "void" : return _freeling.ListSentence_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListSentence_swap(self, *args)
    def get_allocator(self) -> "std::list< freeling::sentence >::allocator_type" : return _freeling.ListSentence_get_allocator(self)
    def begin(self) -> "std::list< freeling::sentence >::iterator" : return _freeling.ListSentence_begin(self)
    def end(self) -> "std::list< freeling::sentence >::iterator" : return _freeling.ListSentence_end(self)
    def rbegin(self) -> "std::list< freeling::sentence >::reverse_iterator" : return _freeling.ListSentence_rbegin(self)
    def rend(self) -> "std::list< freeling::sentence >::reverse_iterator" : return _freeling.ListSentence_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListSentence_pop_back(self)
    def erase(self, *args) -> "std::list< freeling::sentence >::iterator" : return _freeling.ListSentence_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListSentence(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListSentence_push_back(self, *args)
    def front(self) -> "std::list< freeling::sentence >::value_type const &" : return _freeling.ListSentence_front(self)
    def back(self) -> "std::list< freeling::sentence >::value_type const &" : return _freeling.ListSentence_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListSentence_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListSentence_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListSentence_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListSentence_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListSentence_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListSentence_reverse(self)
    __swig_destroy__ = _freeling.delete_ListSentence
    __del__ = lambda self : None;
ListSentence_swigregister = _freeling.ListSentence_swigregister
ListSentence_swigregister(ListSentence)

class ListParagraph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListParagraph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListParagraph, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListParagraph_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListParagraph___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListParagraph___bool__(self)
    def __len__(self) -> "std::list< freeling::paragraph >::size_type" : return _freeling.ListParagraph___len__(self)
    def pop(self) -> "std::list< freeling::paragraph >::value_type" : return _freeling.ListParagraph_pop(self)
    def __getslice__(self, *args) -> "std::list< freeling::paragraph,std::allocator< freeling::paragraph > > *" : return _freeling.ListParagraph___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListParagraph___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListParagraph___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListParagraph___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< freeling::paragraph >::value_type const &" : return _freeling.ListParagraph___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListParagraph___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListParagraph_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListParagraph_empty(self)
    def size(self) -> "std::list< freeling::paragraph >::size_type" : return _freeling.ListParagraph_size(self)
    def clear(self) -> "void" : return _freeling.ListParagraph_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListParagraph_swap(self, *args)
    def get_allocator(self) -> "std::list< freeling::paragraph >::allocator_type" : return _freeling.ListParagraph_get_allocator(self)
    def begin(self) -> "std::list< freeling::paragraph >::iterator" : return _freeling.ListParagraph_begin(self)
    def end(self) -> "std::list< freeling::paragraph >::iterator" : return _freeling.ListParagraph_end(self)
    def rbegin(self) -> "std::list< freeling::paragraph >::reverse_iterator" : return _freeling.ListParagraph_rbegin(self)
    def rend(self) -> "std::list< freeling::paragraph >::reverse_iterator" : return _freeling.ListParagraph_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListParagraph_pop_back(self)
    def erase(self, *args) -> "std::list< freeling::paragraph >::iterator" : return _freeling.ListParagraph_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListParagraph(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListParagraph_push_back(self, *args)
    def front(self) -> "std::list< freeling::paragraph >::value_type const &" : return _freeling.ListParagraph_front(self)
    def back(self) -> "std::list< freeling::paragraph >::value_type const &" : return _freeling.ListParagraph_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListParagraph_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListParagraph_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListParagraph_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListParagraph_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListParagraph_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListParagraph_reverse(self)
    __swig_destroy__ = _freeling.delete_ListParagraph
    __del__ = lambda self : None;
ListParagraph_swigregister = _freeling.ListParagraph_swigregister
ListParagraph_swigregister(ListParagraph)

class ListString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListString___bool__(self)
    def __len__(self) -> "std::list< std::wstring >::size_type" : return _freeling.ListString___len__(self)
    def pop(self) -> "std::list< std::wstring >::value_type" : return _freeling.ListString_pop(self)
    def __getslice__(self, *args) -> "std::list< std::wstring,std::allocator< std::wstring > > *" : return _freeling.ListString___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListString___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListString___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListString___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< std::wstring >::value_type const &" : return _freeling.ListString___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListString___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListString_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListString_empty(self)
    def size(self) -> "std::list< std::wstring >::size_type" : return _freeling.ListString_size(self)
    def clear(self) -> "void" : return _freeling.ListString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListString_swap(self, *args)
    def get_allocator(self) -> "std::list< std::wstring >::allocator_type" : return _freeling.ListString_get_allocator(self)
    def begin(self) -> "std::list< std::wstring >::iterator" : return _freeling.ListString_begin(self)
    def end(self) -> "std::list< std::wstring >::iterator" : return _freeling.ListString_end(self)
    def rbegin(self) -> "std::list< std::wstring >::reverse_iterator" : return _freeling.ListString_rbegin(self)
    def rend(self) -> "std::list< std::wstring >::reverse_iterator" : return _freeling.ListString_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListString_pop_back(self)
    def erase(self, *args) -> "std::list< std::wstring >::iterator" : return _freeling.ListString_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListString_push_back(self, *args)
    def front(self) -> "std::list< std::wstring >::value_type const &" : return _freeling.ListString_front(self)
    def back(self) -> "std::list< std::wstring >::value_type const &" : return _freeling.ListString_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListString_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListString_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListString_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListString_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListString_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListString_reverse(self)
    __swig_destroy__ = _freeling.delete_ListString
    __del__ = lambda self : None;
ListString_swigregister = _freeling.ListString_swigregister
ListString_swigregister(ListString)

class ListInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ListInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ListInt, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.ListInt_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.ListInt___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.ListInt___bool__(self)
    def __len__(self) -> "std::list< int >::size_type" : return _freeling.ListInt___len__(self)
    def pop(self) -> "std::list< int >::value_type" : return _freeling.ListInt_pop(self)
    def __getslice__(self, *args) -> "std::list< int,std::allocator< int > > *" : return _freeling.ListInt___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.ListInt___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.ListInt___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.ListInt___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::list< int >::value_type const &" : return _freeling.ListInt___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.ListInt___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.ListInt_append(self, *args)
    def empty(self) -> "bool" : return _freeling.ListInt_empty(self)
    def size(self) -> "std::list< int >::size_type" : return _freeling.ListInt_size(self)
    def clear(self) -> "void" : return _freeling.ListInt_clear(self)
    def swap(self, *args) -> "void" : return _freeling.ListInt_swap(self, *args)
    def get_allocator(self) -> "std::list< int >::allocator_type" : return _freeling.ListInt_get_allocator(self)
    def begin(self) -> "std::list< int >::iterator" : return _freeling.ListInt_begin(self)
    def end(self) -> "std::list< int >::iterator" : return _freeling.ListInt_end(self)
    def rbegin(self) -> "std::list< int >::reverse_iterator" : return _freeling.ListInt_rbegin(self)
    def rend(self) -> "std::list< int >::reverse_iterator" : return _freeling.ListInt_rend(self)
    def pop_back(self) -> "void" : return _freeling.ListInt_pop_back(self)
    def erase(self, *args) -> "std::list< int >::iterator" : return _freeling.ListInt_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_ListInt(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.ListInt_push_back(self, *args)
    def front(self) -> "std::list< int >::value_type const &" : return _freeling.ListInt_front(self)
    def back(self) -> "std::list< int >::value_type const &" : return _freeling.ListInt_back(self)
    def assign(self, *args) -> "void" : return _freeling.ListInt_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.ListInt_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.ListInt_insert(self, *args)
    def pop_front(self) -> "void" : return _freeling.ListInt_pop_front(self)
    def push_front(self, *args) -> "void" : return _freeling.ListInt_push_front(self, *args)
    def reverse(self) -> "void" : return _freeling.ListInt_reverse(self)
    __swig_destroy__ = _freeling.delete_ListInt
    __del__ = lambda self : None;
ListInt_swigregister = _freeling.ListInt_swigregister
ListInt_swigregister(ListInt)

class VectorListInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorListInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorListInt, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorListInt_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorListInt___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorListInt___bool__(self)
    def __len__(self) -> "std::vector< std::list< int > >::size_type" : return _freeling.VectorListInt___len__(self)
    def pop(self) -> "std::vector< std::list< int > >::value_type" : return _freeling.VectorListInt_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::list< int,std::allocator< int > >,std::allocator< std::list< int,std::allocator< int > > > > *" : return _freeling.VectorListInt___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorListInt___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorListInt___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorListInt___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::list< int > >::value_type const &" : return _freeling.VectorListInt___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorListInt___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorListInt_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorListInt_empty(self)
    def size(self) -> "std::vector< std::list< int > >::size_type" : return _freeling.VectorListInt_size(self)
    def clear(self) -> "void" : return _freeling.VectorListInt_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorListInt_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::list< int > >::allocator_type" : return _freeling.VectorListInt_get_allocator(self)
    def begin(self) -> "std::vector< std::list< int > >::iterator" : return _freeling.VectorListInt_begin(self)
    def end(self) -> "std::vector< std::list< int > >::iterator" : return _freeling.VectorListInt_end(self)
    def rbegin(self) -> "std::vector< std::list< int > >::reverse_iterator" : return _freeling.VectorListInt_rbegin(self)
    def rend(self) -> "std::vector< std::list< int > >::reverse_iterator" : return _freeling.VectorListInt_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorListInt_pop_back(self)
    def erase(self, *args) -> "std::vector< std::list< int > >::iterator" : return _freeling.VectorListInt_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorListInt(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorListInt_push_back(self, *args)
    def front(self) -> "std::vector< std::list< int > >::value_type const &" : return _freeling.VectorListInt_front(self)
    def back(self) -> "std::vector< std::list< int > >::value_type const &" : return _freeling.VectorListInt_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorListInt_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorListInt_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorListInt_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorListInt_reserve(self, *args)
    def capacity(self) -> "std::vector< std::list< int > >::size_type" : return _freeling.VectorListInt_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorListInt
    __del__ = lambda self : None;
VectorListInt_swigregister = _freeling.VectorListInt_swigregister
VectorListInt_swigregister(VectorListInt)

class VectorListString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorListString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorListString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorListString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorListString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorListString___bool__(self)
    def __len__(self) -> "std::vector< std::list< std::wstring > >::size_type" : return _freeling.VectorListString___len__(self)
    def pop(self) -> "std::vector< std::list< std::wstring > >::value_type" : return _freeling.VectorListString_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::list< std::wstring,std::allocator< std::wstring > >,std::allocator< std::list< std::wstring,std::allocator< std::wstring > > > > *" : return _freeling.VectorListString___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorListString___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorListString___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorListString___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::list< std::wstring > >::value_type const &" : return _freeling.VectorListString___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorListString___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorListString_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorListString_empty(self)
    def size(self) -> "std::vector< std::list< std::wstring > >::size_type" : return _freeling.VectorListString_size(self)
    def clear(self) -> "void" : return _freeling.VectorListString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorListString_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::list< std::wstring > >::allocator_type" : return _freeling.VectorListString_get_allocator(self)
    def begin(self) -> "std::vector< std::list< std::wstring > >::iterator" : return _freeling.VectorListString_begin(self)
    def end(self) -> "std::vector< std::list< std::wstring > >::iterator" : return _freeling.VectorListString_end(self)
    def rbegin(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator" : return _freeling.VectorListString_rbegin(self)
    def rend(self) -> "std::vector< std::list< std::wstring > >::reverse_iterator" : return _freeling.VectorListString_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorListString_pop_back(self)
    def erase(self, *args) -> "std::vector< std::list< std::wstring > >::iterator" : return _freeling.VectorListString_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorListString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorListString_push_back(self, *args)
    def front(self) -> "std::vector< std::list< std::wstring > >::value_type const &" : return _freeling.VectorListString_front(self)
    def back(self) -> "std::vector< std::list< std::wstring > >::value_type const &" : return _freeling.VectorListString_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorListString_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorListString_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorListString_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorListString_reserve(self, *args)
    def capacity(self) -> "std::vector< std::list< std::wstring > >::size_type" : return _freeling.VectorListString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorListString
    __del__ = lambda self : None;
VectorListString_swigregister = _freeling.VectorListString_swigregister
VectorListString_swigregister(VectorListString)

class VectorString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorString___bool__(self)
    def __len__(self) -> "std::vector< std::wstring >::size_type" : return _freeling.VectorString___len__(self)
    def pop(self) -> "std::vector< std::wstring >::value_type" : return _freeling.VectorString_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::wstring,std::allocator< std::wstring > > *" : return _freeling.VectorString___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorString___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorString___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorString___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::wstring >::value_type const &" : return _freeling.VectorString___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorString___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorString_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorString_empty(self)
    def size(self) -> "std::vector< std::wstring >::size_type" : return _freeling.VectorString_size(self)
    def clear(self) -> "void" : return _freeling.VectorString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorString_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::wstring >::allocator_type" : return _freeling.VectorString_get_allocator(self)
    def begin(self) -> "std::vector< std::wstring >::iterator" : return _freeling.VectorString_begin(self)
    def end(self) -> "std::vector< std::wstring >::iterator" : return _freeling.VectorString_end(self)
    def rbegin(self) -> "std::vector< std::wstring >::reverse_iterator" : return _freeling.VectorString_rbegin(self)
    def rend(self) -> "std::vector< std::wstring >::reverse_iterator" : return _freeling.VectorString_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorString_pop_back(self)
    def erase(self, *args) -> "std::vector< std::wstring >::iterator" : return _freeling.VectorString_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorString_push_back(self, *args)
    def front(self) -> "std::vector< std::wstring >::value_type const &" : return _freeling.VectorString_front(self)
    def back(self) -> "std::vector< std::wstring >::value_type const &" : return _freeling.VectorString_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorString_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorString_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorString_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorString_reserve(self, *args)
    def capacity(self) -> "std::vector< std::wstring >::size_type" : return _freeling.VectorString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorString
    __del__ = lambda self : None;
VectorString_swigregister = _freeling.VectorString_swigregister
VectorString_swigregister(VectorString)

class PairDoubleString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairDoubleString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairDoubleString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_PairDoubleString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _freeling.PairDoubleString_first_set
    __swig_getmethods__["first"] = _freeling.PairDoubleString_first_get
    if _newclass:first = _swig_property(_freeling.PairDoubleString_first_get, _freeling.PairDoubleString_first_set)
    __swig_setmethods__["second"] = _freeling.PairDoubleString_second_set
    __swig_getmethods__["second"] = _freeling.PairDoubleString_second_get
    if _newclass:second = _swig_property(_freeling.PairDoubleString_second_get, _freeling.PairDoubleString_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _freeling.delete_PairDoubleString
    __del__ = lambda self : None;
PairDoubleString_swigregister = _freeling.PairDoubleString_swigregister
PairDoubleString_swigregister(PairDoubleString)

class VectorPairDoubleString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPairDoubleString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPairDoubleString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorPairDoubleString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorPairDoubleString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorPairDoubleString___bool__(self)
    def __len__(self) -> "std::vector< std::pair< double,std::wstring > >::size_type" : return _freeling.VectorPairDoubleString___len__(self)
    def pop(self) -> "std::vector< std::pair< double,std::wstring > >::value_type" : return _freeling.VectorPairDoubleString_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::pair< double,std::wstring >,std::allocator< std::pair< double,std::wstring > > > *" : return _freeling.VectorPairDoubleString___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorPairDoubleString___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorPairDoubleString___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorPairDoubleString___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::pair< double,std::wstring > >::value_type const &" : return _freeling.VectorPairDoubleString___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorPairDoubleString___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorPairDoubleString_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorPairDoubleString_empty(self)
    def size(self) -> "std::vector< std::pair< double,std::wstring > >::size_type" : return _freeling.VectorPairDoubleString_size(self)
    def clear(self) -> "void" : return _freeling.VectorPairDoubleString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorPairDoubleString_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::pair< double,std::wstring > >::allocator_type" : return _freeling.VectorPairDoubleString_get_allocator(self)
    def begin(self) -> "std::vector< std::pair< double,std::wstring > >::iterator" : return _freeling.VectorPairDoubleString_begin(self)
    def end(self) -> "std::vector< std::pair< double,std::wstring > >::iterator" : return _freeling.VectorPairDoubleString_end(self)
    def rbegin(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator" : return _freeling.VectorPairDoubleString_rbegin(self)
    def rend(self) -> "std::vector< std::pair< double,std::wstring > >::reverse_iterator" : return _freeling.VectorPairDoubleString_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorPairDoubleString_pop_back(self)
    def erase(self, *args) -> "std::vector< std::pair< double,std::wstring > >::iterator" : return _freeling.VectorPairDoubleString_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorPairDoubleString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorPairDoubleString_push_back(self, *args)
    def front(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &" : return _freeling.VectorPairDoubleString_front(self)
    def back(self) -> "std::vector< std::pair< double,std::wstring > >::value_type const &" : return _freeling.VectorPairDoubleString_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorPairDoubleString_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorPairDoubleString_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorPairDoubleString_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorPairDoubleString_reserve(self, *args)
    def capacity(self) -> "std::vector< std::pair< double,std::wstring > >::size_type" : return _freeling.VectorPairDoubleString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorPairDoubleString
    __del__ = lambda self : None;
VectorPairDoubleString_swigregister = _freeling.VectorPairDoubleString_swigregister
VectorPairDoubleString_swigregister(VectorPairDoubleString)

class PairStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairStringString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_PairStringString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _freeling.PairStringString_first_set
    __swig_getmethods__["first"] = _freeling.PairStringString_first_get
    if _newclass:first = _swig_property(_freeling.PairStringString_first_get, _freeling.PairStringString_first_set)
    __swig_setmethods__["second"] = _freeling.PairStringString_second_set
    __swig_getmethods__["second"] = _freeling.PairStringString_second_get
    if _newclass:second = _swig_property(_freeling.PairStringString_second_get, _freeling.PairStringString_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _freeling.delete_PairStringString
    __del__ = lambda self : None;
PairStringString_swigregister = _freeling.PairStringString_swigregister
PairStringString_swigregister(PairStringString)

class VectorPairStringString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPairStringString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPairStringString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.VectorPairStringString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.VectorPairStringString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.VectorPairStringString___bool__(self)
    def __len__(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type" : return _freeling.VectorPairStringString___len__(self)
    def pop(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type" : return _freeling.VectorPairStringString_pop(self)
    def __getslice__(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > > *" : return _freeling.VectorPairStringString___getslice__(self, *args)
    def __setslice__(self, *args) -> "void" : return _freeling.VectorPairStringString___setslice__(self, *args)
    def __delslice__(self, *args) -> "void" : return _freeling.VectorPairStringString___delslice__(self, *args)
    def __delitem__(self, *args) -> "void" : return _freeling.VectorPairStringString___delitem__(self, *args)
    def __getitem__(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &" : return _freeling.VectorPairStringString___getitem__(self, *args)
    def __setitem__(self, *args) -> "void" : return _freeling.VectorPairStringString___setitem__(self, *args)
    def append(self, *args) -> "void" : return _freeling.VectorPairStringString_append(self, *args)
    def empty(self) -> "bool" : return _freeling.VectorPairStringString_empty(self)
    def size(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type" : return _freeling.VectorPairStringString_size(self)
    def clear(self) -> "void" : return _freeling.VectorPairStringString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.VectorPairStringString_swap(self, *args)
    def get_allocator(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::allocator_type" : return _freeling.VectorPairStringString_get_allocator(self)
    def begin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator" : return _freeling.VectorPairStringString_begin(self)
    def end(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator" : return _freeling.VectorPairStringString_end(self)
    def rbegin(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator" : return _freeling.VectorPairStringString_rbegin(self)
    def rend(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::reverse_iterator" : return _freeling.VectorPairStringString_rend(self)
    def pop_back(self) -> "void" : return _freeling.VectorPairStringString_pop_back(self)
    def erase(self, *args) -> "std::vector< std::pair< std::wstring,std::wstring > >::iterator" : return _freeling.VectorPairStringString_erase(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_VectorPairStringString(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args) -> "void" : return _freeling.VectorPairStringString_push_back(self, *args)
    def front(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &" : return _freeling.VectorPairStringString_front(self)
    def back(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::value_type const &" : return _freeling.VectorPairStringString_back(self)
    def assign(self, *args) -> "void" : return _freeling.VectorPairStringString_assign(self, *args)
    def resize(self, *args) -> "void" : return _freeling.VectorPairStringString_resize(self, *args)
    def insert(self, *args) -> "void" : return _freeling.VectorPairStringString_insert(self, *args)
    def reserve(self, *args) -> "void" : return _freeling.VectorPairStringString_reserve(self, *args)
    def capacity(self) -> "std::vector< std::pair< std::wstring,std::wstring > >::size_type" : return _freeling.VectorPairStringString_capacity(self)
    __swig_destroy__ = _freeling.delete_VectorPairStringString
    __del__ = lambda self : None;
VectorPairStringString_swigregister = _freeling.VectorPairStringString_swigregister
VectorPairStringString_swigregister(VectorPairStringString)

class PairStringInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairStringInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairStringInt, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_PairStringInt(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _freeling.PairStringInt_first_set
    __swig_getmethods__["first"] = _freeling.PairStringInt_first_get
    if _newclass:first = _swig_property(_freeling.PairStringInt_first_get, _freeling.PairStringInt_first_set)
    __swig_setmethods__["second"] = _freeling.PairStringInt_second_set
    __swig_getmethods__["second"] = _freeling.PairStringInt_second_get
    if _newclass:second = _swig_property(_freeling.PairStringInt_second_get, _freeling.PairStringInt_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _freeling.delete_PairStringInt
    __del__ = lambda self : None;
PairStringInt_swigregister = _freeling.PairStringInt_swigregister
PairStringInt_swigregister(PairStringInt)

class SetString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SetString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SetString, name)
    __repr__ = _swig_repr
    def iterator(self) -> "swig::SwigPyIterator *" : return _freeling.SetString_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self) -> "bool" : return _freeling.SetString___nonzero__(self)
    def __bool__(self) -> "bool" : return _freeling.SetString___bool__(self)
    def __len__(self) -> "std::set< std::wstring >::size_type" : return _freeling.SetString___len__(self)
    def append(self, *args) -> "void" : return _freeling.SetString_append(self, *args)
    def __contains__(self, *args) -> "bool" : return _freeling.SetString___contains__(self, *args)
    def __getitem__(self, *args) -> "std::set< std::wstring >::value_type" : return _freeling.SetString___getitem__(self, *args)
    def add(self, *args) -> "void" : return _freeling.SetString_add(self, *args)
    def discard(self, *args) -> "void" : return _freeling.SetString_discard(self, *args)
    def __init__(self, *args): 
        this = _freeling.new_SetString(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self) -> "bool" : return _freeling.SetString_empty(self)
    def size(self) -> "std::set< std::wstring >::size_type" : return _freeling.SetString_size(self)
    def clear(self) -> "void" : return _freeling.SetString_clear(self)
    def swap(self, *args) -> "void" : return _freeling.SetString_swap(self, *args)
    def count(self, *args) -> "std::set< std::wstring >::size_type" : return _freeling.SetString_count(self, *args)
    def begin(self) -> "std::set< std::wstring >::iterator" : return _freeling.SetString_begin(self)
    def end(self) -> "std::set< std::wstring >::iterator" : return _freeling.SetString_end(self)
    def rbegin(self) -> "std::set< std::wstring >::reverse_iterator" : return _freeling.SetString_rbegin(self)
    def rend(self) -> "std::set< std::wstring >::reverse_iterator" : return _freeling.SetString_rend(self)
    def erase(self, *args) -> "void" : return _freeling.SetString_erase(self, *args)
    def find(self, *args) -> "std::set< std::wstring >::iterator" : return _freeling.SetString_find(self, *args)
    def lower_bound(self, *args) -> "std::set< std::wstring >::iterator" : return _freeling.SetString_lower_bound(self, *args)
    def upper_bound(self, *args) -> "std::set< std::wstring >::iterator" : return _freeling.SetString_upper_bound(self, *args)
    def equal_range(self, *args) -> "std::pair< std::set< std::wstring >::iterator,std::set< std::wstring >::iterator >" : return _freeling.SetString_equal_range(self, *args)
    def insert(self, *args) -> "std::pair< std::set< std::wstring >::iterator,bool >" : return _freeling.SetString_insert(self, *args)
    __swig_destroy__ = _freeling.delete_SetString
    __del__ = lambda self : None;
SetString_swigregister = _freeling.SetString_swigregister
SetString_swigregister(SetString)

class TreeIteratorNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeIteratorNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_TreeIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeIteratorNode
    __del__ = lambda self : None;
    def __ref__(self) -> "freeling::tree< freeling::node > const &" : return _freeling.TreeIteratorNode___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::node > const *" : return _freeling.TreeIteratorNode___deref__(self)
    def __eq__(self, *args) -> "bool" : return _freeling.TreeIteratorNode___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _freeling.TreeIteratorNode___ne__(self, *args)
    __swig_getmethods__["info"] = _freeling.TreeIteratorNode_info_get
    if _newclass:info = _swig_property(_freeling.TreeIteratorNode_info_get)
    def num_children(self) -> "unsigned int" : return _freeling.TreeIteratorNode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::node >::sibling_iterator" : return _freeling.TreeIteratorNode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::node >::iterator" : return _freeling.TreeIteratorNode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > &" : return _freeling.TreeIteratorNode_nth_child_ref(self, *args)
    def empty(self) -> "bool" : return _freeling.TreeIteratorNode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeIteratorNode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeIteratorNode_end(self, *args)
TreeIteratorNode_swigregister = _freeling.TreeIteratorNode_swigregister
TreeIteratorNode_swigregister(TreeIteratorNode)

class GenericIteratorNode(TreeIteratorNode):
    __swig_setmethods__ = {}
    for _s in [TreeIteratorNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeIteratorNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_GenericIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ref__(self) -> "freeling::tree< freeling::node > &" : return _freeling.GenericIteratorNode___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::node > *" : return _freeling.GenericIteratorNode___deref__(self)
    __swig_destroy__ = _freeling.delete_GenericIteratorNode
    __del__ = lambda self : None;
    __swig_setmethods__["info"] = _freeling.GenericIteratorNode_info_set
    __swig_getmethods__["info"] = _freeling.GenericIteratorNode_info_get
    if _newclass:info = _swig_property(_freeling.GenericIteratorNode_info_get, _freeling.GenericIteratorNode_info_set)
    def num_children(self) -> "unsigned int" : return _freeling.GenericIteratorNode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::node >::sibling_iterator" : return _freeling.GenericIteratorNode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::node >::iterator" : return _freeling.GenericIteratorNode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > &" : return _freeling.GenericIteratorNode_nth_child_ref(self, *args)
    def get_info(self) -> "freeling::node &" : return _freeling.GenericIteratorNode_get_info(self)
    def append_child(self, *args) -> "void" : return _freeling.GenericIteratorNode_append_child(self, *args)
    def hang_child(self, *args) -> "void" : return _freeling.GenericIteratorNode_hang_child(self, *args)
    def clear(self) -> "void" : return _freeling.GenericIteratorNode_clear(self)
    def empty(self) -> "bool" : return _freeling.GenericIteratorNode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.GenericIteratorNode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.GenericIteratorNode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.GenericIteratorNode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.GenericIteratorNode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.GenericIteratorNode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.GenericIteratorNode_end(self, *args)
GenericIteratorNode_swigregister = _freeling.GenericIteratorNode_swigregister
GenericIteratorNode_swigregister(GenericIteratorNode)

class PreorderIteratorNode(GenericIteratorNode):
    __swig_setmethods__ = {}
    for _s in [GenericIteratorNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreorderIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericIteratorNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PreorderIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_PreorderIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_PreorderIteratorNode
    __del__ = lambda self : None;
PreorderIteratorNode_swigregister = _freeling.PreorderIteratorNode_swigregister
PreorderIteratorNode_swigregister(PreorderIteratorNode)

class SiblingIteratorNode(GenericIteratorNode):
    __swig_setmethods__ = {}
    for _s in [GenericIteratorNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SiblingIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericIteratorNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SiblingIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_SiblingIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_SiblingIteratorNode
    __del__ = lambda self : None;
SiblingIteratorNode_swigregister = _freeling.SiblingIteratorNode_swigregister
SiblingIteratorNode_swigregister(SiblingIteratorNode)

class TreeIteratorDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_TreeIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeIteratorDepnode
    __del__ = lambda self : None;
    def __ref__(self) -> "freeling::tree< freeling::depnode > const &" : return _freeling.TreeIteratorDepnode___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::depnode > const *" : return _freeling.TreeIteratorDepnode___deref__(self)
    def __eq__(self, *args) -> "bool" : return _freeling.TreeIteratorDepnode___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _freeling.TreeIteratorDepnode___ne__(self, *args)
    __swig_getmethods__["info"] = _freeling.TreeIteratorDepnode_info_get
    if _newclass:info = _swig_property(_freeling.TreeIteratorDepnode_info_get)
    def num_children(self) -> "unsigned int" : return _freeling.TreeIteratorDepnode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::sibling_iterator" : return _freeling.TreeIteratorDepnode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::depnode >::iterator" : return _freeling.TreeIteratorDepnode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > &" : return _freeling.TreeIteratorDepnode_nth_child_ref(self, *args)
    def empty(self) -> "bool" : return _freeling.TreeIteratorDepnode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeIteratorDepnode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeIteratorDepnode_end(self, *args)
TreeIteratorDepnode_swigregister = _freeling.TreeIteratorDepnode_swigregister
TreeIteratorDepnode_swigregister(TreeIteratorDepnode)

class GenericIteratorDepnode(TreeIteratorDepnode):
    __swig_setmethods__ = {}
    for _s in [TreeIteratorDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeIteratorDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_GenericIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    def __ref__(self) -> "freeling::tree< freeling::depnode > &" : return _freeling.GenericIteratorDepnode___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::depnode > *" : return _freeling.GenericIteratorDepnode___deref__(self)
    __swig_destroy__ = _freeling.delete_GenericIteratorDepnode
    __del__ = lambda self : None;
    __swig_setmethods__["info"] = _freeling.GenericIteratorDepnode_info_set
    __swig_getmethods__["info"] = _freeling.GenericIteratorDepnode_info_get
    if _newclass:info = _swig_property(_freeling.GenericIteratorDepnode_info_get, _freeling.GenericIteratorDepnode_info_set)
    def num_children(self) -> "unsigned int" : return _freeling.GenericIteratorDepnode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::sibling_iterator" : return _freeling.GenericIteratorDepnode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::depnode >::iterator" : return _freeling.GenericIteratorDepnode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > &" : return _freeling.GenericIteratorDepnode_nth_child_ref(self, *args)
    def get_info(self) -> "freeling::depnode &" : return _freeling.GenericIteratorDepnode_get_info(self)
    def append_child(self, *args) -> "void" : return _freeling.GenericIteratorDepnode_append_child(self, *args)
    def hang_child(self, *args) -> "void" : return _freeling.GenericIteratorDepnode_hang_child(self, *args)
    def clear(self) -> "void" : return _freeling.GenericIteratorDepnode_clear(self)
    def empty(self) -> "bool" : return _freeling.GenericIteratorDepnode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.GenericIteratorDepnode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.GenericIteratorDepnode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.GenericIteratorDepnode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.GenericIteratorDepnode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.GenericIteratorDepnode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.GenericIteratorDepnode_end(self, *args)
GenericIteratorDepnode_swigregister = _freeling.GenericIteratorDepnode_swigregister
GenericIteratorDepnode_swigregister(GenericIteratorDepnode)

class PreorderIteratorDepnode(GenericIteratorDepnode):
    __swig_setmethods__ = {}
    for _s in [GenericIteratorDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreorderIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericIteratorDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PreorderIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_PreorderIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_PreorderIteratorDepnode
    __del__ = lambda self : None;
PreorderIteratorDepnode_swigregister = _freeling.PreorderIteratorDepnode_swigregister
PreorderIteratorDepnode_swigregister(PreorderIteratorDepnode)

class SiblingIteratorDepnode(GenericIteratorDepnode):
    __swig_setmethods__ = {}
    for _s in [GenericIteratorDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SiblingIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericIteratorDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SiblingIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_SiblingIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_SiblingIteratorDepnode
    __del__ = lambda self : None;
SiblingIteratorDepnode_swigregister = _freeling.SiblingIteratorDepnode_swigregister
SiblingIteratorDepnode_swigregister(SiblingIteratorDepnode)

class TreeIteratorNodeConst(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeIteratorNodeConst, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeIteratorNodeConst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_TreeIteratorNodeConst(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeIteratorNodeConst
    __del__ = lambda self : None;
    def __ref__(self) -> "freeling::tree< freeling::node > const &" : return _freeling.TreeIteratorNodeConst___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::node > const *" : return _freeling.TreeIteratorNodeConst___deref__(self)
    def __eq__(self, *args) -> "bool" : return _freeling.TreeIteratorNodeConst___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _freeling.TreeIteratorNodeConst___ne__(self, *args)
    __swig_getmethods__["info"] = _freeling.TreeIteratorNodeConst_info_get
    if _newclass:info = _swig_property(_freeling.TreeIteratorNodeConst_info_get)
    def num_children(self) -> "unsigned int" : return _freeling.TreeIteratorNodeConst_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::node >::sibling_iterator" : return _freeling.TreeIteratorNodeConst_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::node >::iterator" : return _freeling.TreeIteratorNodeConst_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > &" : return _freeling.TreeIteratorNodeConst_nth_child_ref(self, *args)
    def empty(self) -> "bool" : return _freeling.TreeIteratorNodeConst_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNodeConst_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNodeConst_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNodeConst_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeIteratorNodeConst_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeIteratorNodeConst_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeIteratorNodeConst_end(self, *args)
TreeIteratorNodeConst_swigregister = _freeling.TreeIteratorNodeConst_swigregister
TreeIteratorNodeConst_swigregister(TreeIteratorNodeConst)

class GenericConstIteratorNode(TreeIteratorNodeConst):
    __swig_setmethods__ = {}
    for _s in [TreeIteratorNodeConst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericConstIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeIteratorNodeConst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericConstIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_GenericConstIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_GenericConstIteratorNode
    __del__ = lambda self : None;
GenericConstIteratorNode_swigregister = _freeling.GenericConstIteratorNode_swigregister
GenericConstIteratorNode_swigregister(GenericConstIteratorNode)

class ConstPreorderIteratorNode(GenericConstIteratorNode):
    __swig_setmethods__ = {}
    for _s in [GenericConstIteratorNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstPreorderIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericConstIteratorNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstPreorderIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ConstPreorderIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ConstPreorderIteratorNode
    __del__ = lambda self : None;
ConstPreorderIteratorNode_swigregister = _freeling.ConstPreorderIteratorNode_swigregister
ConstPreorderIteratorNode_swigregister(ConstPreorderIteratorNode)

class ConstSiblingIteratorNode(GenericConstIteratorNode):
    __swig_setmethods__ = {}
    for _s in [GenericConstIteratorNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstSiblingIteratorNode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericConstIteratorNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstSiblingIteratorNode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ConstSiblingIteratorNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ConstSiblingIteratorNode
    __del__ = lambda self : None;
ConstSiblingIteratorNode_swigregister = _freeling.ConstSiblingIteratorNode_swigregister
ConstSiblingIteratorNode_swigregister(ConstSiblingIteratorNode)

class TreeIteratorDepnodeConst(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeIteratorDepnodeConst, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeIteratorDepnodeConst, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_TreeIteratorDepnodeConst(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeIteratorDepnodeConst
    __del__ = lambda self : None;
    def __ref__(self) -> "freeling::tree< freeling::depnode > const &" : return _freeling.TreeIteratorDepnodeConst___ref__(self)
    def __deref__(self) -> "freeling::tree< freeling::depnode > const *" : return _freeling.TreeIteratorDepnodeConst___deref__(self)
    def __eq__(self, *args) -> "bool" : return _freeling.TreeIteratorDepnodeConst___eq__(self, *args)
    def __ne__(self, *args) -> "bool" : return _freeling.TreeIteratorDepnodeConst___ne__(self, *args)
    __swig_getmethods__["info"] = _freeling.TreeIteratorDepnodeConst_info_get
    if _newclass:info = _swig_property(_freeling.TreeIteratorDepnodeConst_info_get)
    def num_children(self) -> "unsigned int" : return _freeling.TreeIteratorDepnodeConst_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::sibling_iterator" : return _freeling.TreeIteratorDepnodeConst_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::depnode >::iterator" : return _freeling.TreeIteratorDepnodeConst_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > &" : return _freeling.TreeIteratorDepnodeConst_nth_child_ref(self, *args)
    def empty(self) -> "bool" : return _freeling.TreeIteratorDepnodeConst_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnodeConst_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnodeConst_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnodeConst_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeIteratorDepnodeConst_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeIteratorDepnodeConst_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeIteratorDepnodeConst_end(self, *args)
TreeIteratorDepnodeConst_swigregister = _freeling.TreeIteratorDepnodeConst_swigregister
TreeIteratorDepnodeConst_swigregister(TreeIteratorDepnodeConst)

class GenericConstIteratorDepnode(TreeIteratorDepnodeConst):
    __swig_setmethods__ = {}
    for _s in [TreeIteratorDepnodeConst]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericConstIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeIteratorDepnodeConst]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenericConstIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_GenericConstIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_GenericConstIteratorDepnode
    __del__ = lambda self : None;
GenericConstIteratorDepnode_swigregister = _freeling.GenericConstIteratorDepnode_swigregister
GenericConstIteratorDepnode_swigregister(GenericConstIteratorDepnode)

class ConstPreorderIteratorDepnode(GenericConstIteratorDepnode):
    __swig_setmethods__ = {}
    for _s in [GenericConstIteratorDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstPreorderIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericConstIteratorDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstPreorderIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ConstPreorderIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ConstPreorderIteratorDepnode
    __del__ = lambda self : None;
ConstPreorderIteratorDepnode_swigregister = _freeling.ConstPreorderIteratorDepnode_swigregister
ConstPreorderIteratorDepnode_swigregister(ConstPreorderIteratorDepnode)

class ConstSiblingIteratorDepnode(GenericConstIteratorDepnode):
    __swig_setmethods__ = {}
    for _s in [GenericConstIteratorDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstSiblingIteratorDepnode, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericConstIteratorDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstSiblingIteratorDepnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ConstSiblingIteratorDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ConstSiblingIteratorDepnode
    __del__ = lambda self : None;
ConstSiblingIteratorDepnode_swigregister = _freeling.ConstSiblingIteratorDepnode_swigregister
ConstSiblingIteratorDepnode_swigregister(ConstSiblingIteratorDepnode)

class TreeNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeNode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["info"] = _freeling.TreeNode_info_set
    __swig_getmethods__["info"] = _freeling.TreeNode_info_get
    if _newclass:info = _swig_property(_freeling.TreeNode_info_get, _freeling.TreeNode_info_set)
    def __init__(self, *args): 
        this = _freeling.new_TreeNode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeNode
    __del__ = lambda self : None;
    def num_children(self) -> "unsigned int" : return _freeling.TreeNode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::node >::sibling_iterator" : return _freeling.TreeNode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::node >::iterator" : return _freeling.TreeNode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::node > &" : return _freeling.TreeNode_nth_child_ref(self, *args)
    def get_info(self) -> "freeling::node &" : return _freeling.TreeNode_get_info(self)
    def append_child(self, *args) -> "void" : return _freeling.TreeNode_append_child(self, *args)
    def hang_child(self, *args) -> "void" : return _freeling.TreeNode_hang_child(self, *args)
    def clear(self) -> "void" : return _freeling.TreeNode_clear(self)
    def empty(self) -> "bool" : return _freeling.TreeNode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeNode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeNode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeNode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::node >::const_sibling_iterator" : return _freeling.TreeNode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeNode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::node >::const_preorder_iterator" : return _freeling.TreeNode_end(self, *args)
TreeNode_swigregister = _freeling.TreeNode_swigregister
TreeNode_swigregister(TreeNode)

class TreeDepnode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeDepnode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeDepnode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["info"] = _freeling.TreeDepnode_info_set
    __swig_getmethods__["info"] = _freeling.TreeDepnode_info_get
    if _newclass:info = _swig_property(_freeling.TreeDepnode_info_get, _freeling.TreeDepnode_info_set)
    def __init__(self, *args): 
        this = _freeling.new_TreeDepnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_TreeDepnode
    __del__ = lambda self : None;
    def num_children(self) -> "unsigned int" : return _freeling.TreeDepnode_num_children(self)
    def nth_child(self, *args) -> "freeling::tree< freeling::depnode >::sibling_iterator" : return _freeling.TreeDepnode_nth_child(self, *args)
    def get_parent(self) -> "freeling::tree< freeling::depnode >::iterator" : return _freeling.TreeDepnode_get_parent(self)
    def nth_child_ref(self, *args) -> "freeling::tree< freeling::depnode > &" : return _freeling.TreeDepnode_nth_child_ref(self, *args)
    def get_info(self) -> "freeling::depnode &" : return _freeling.TreeDepnode_get_info(self)
    def append_child(self, *args) -> "void" : return _freeling.TreeDepnode_append_child(self, *args)
    def hang_child(self, *args) -> "void" : return _freeling.TreeDepnode_hang_child(self, *args)
    def clear(self) -> "void" : return _freeling.TreeDepnode_clear(self)
    def empty(self) -> "bool" : return _freeling.TreeDepnode_empty(self)
    def sibling_begin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeDepnode_sibling_begin(self, *args)
    def sibling_end(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeDepnode_sibling_end(self, *args)
    def sibling_rbegin(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeDepnode_sibling_rbegin(self, *args)
    def sibling_rend(self, *args) -> "freeling::tree< freeling::depnode >::const_sibling_iterator" : return _freeling.TreeDepnode_sibling_rend(self, *args)
    def begin(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeDepnode_begin(self, *args)
    def end(self, *args) -> "freeling::tree< freeling::depnode >::const_preorder_iterator" : return _freeling.TreeDepnode_end(self, *args)
TreeDepnode_swigregister = _freeling.TreeDepnode_swigregister
TreeDepnode_swigregister(TreeDepnode)

class analysis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, analysis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, analysis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["user"] = _freeling.analysis_user_set
    __swig_getmethods__["user"] = _freeling.analysis_user_get
    if _newclass:user = _swig_property(_freeling.analysis_user_get, _freeling.analysis_user_set)
    def __init__(self, *args): 
        this = _freeling.new_analysis(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_analysis
    __del__ = lambda self : None;
    def init(self, *args) -> "void" : return _freeling.analysis_init(self, *args)
    def set_lemma(self, *args) -> "void" : return _freeling.analysis_set_lemma(self, *args)
    def set_tag(self, *args) -> "void" : return _freeling.analysis_set_tag(self, *args)
    def set_prob(self, *args) -> "void" : return _freeling.analysis_set_prob(self, *args)
    def set_distance(self, *args) -> "void" : return _freeling.analysis_set_distance(self, *args)
    def set_retokenizable(self, *args) -> "void" : return _freeling.analysis_set_retokenizable(self, *args)
    def has_prob(self) -> "bool" : return _freeling.analysis_has_prob(self)
    def has_distance(self) -> "bool" : return _freeling.analysis_has_distance(self)
    def get_lemma(self) -> "std::wstring" : return _freeling.analysis_get_lemma(self)
    def get_tag(self) -> "std::wstring" : return _freeling.analysis_get_tag(self)
    def get_prob(self) -> "double" : return _freeling.analysis_get_prob(self)
    def get_distance(self) -> "double" : return _freeling.analysis_get_distance(self)
    def is_retokenizable(self) -> "bool" : return _freeling.analysis_is_retokenizable(self)
    def get_retokenizable(self) -> "std::list< freeling::word,std::allocator< freeling::word > >" : return _freeling.analysis_get_retokenizable(self)
    def get_senses(self) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >" : return _freeling.analysis_get_senses(self)
    def set_senses(self, *args) -> "void" : return _freeling.analysis_set_senses(self, *args)
    def get_senses_string(self) -> "std::wstring" : return _freeling.analysis_get_senses_string(self)
    def __gt__(self, *args) -> "bool" : return _freeling.analysis___gt__(self, *args)
    def __lt__(self, *args) -> "bool" : return _freeling.analysis___lt__(self, *args)
    def __eq__(self, *args) -> "bool" : return _freeling.analysis___eq__(self, *args)
    def is_selected(self, k : 'int'=0) -> "bool" : return _freeling.analysis_is_selected(self, k)
    def mark_selected(self, k : 'int'=0) -> "void" : return _freeling.analysis_mark_selected(self, k)
    def unmark_selected(self, k : 'int'=0) -> "void" : return _freeling.analysis_unmark_selected(self, k)
analysis_swigregister = _freeling.analysis_swigregister
analysis_swigregister(analysis)

class word(ListAnalysis):
    __swig_setmethods__ = {}
    for _s in [ListAnalysis]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, word, name, value)
    __swig_getmethods__ = {}
    for _s in [ListAnalysis]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, word, name)
    __repr__ = _swig_repr
    __swig_setmethods__["user"] = _freeling.word_user_set
    __swig_getmethods__["user"] = _freeling.word_user_get
    if _newclass:user = _swig_property(_freeling.word_user_get, _freeling.word_user_set)
    def __init__(self, *args): 
        this = _freeling.new_word(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_word
    __del__ = lambda self : None;
    def copy_analysis(self, *args) -> "void" : return _freeling.word_copy_analysis(self, *args)
    def get_n_selected(self) -> "int" : return _freeling.word_get_n_selected(self)
    def get_n_unselected(self) -> "int" : return _freeling.word_get_n_unselected(self)
    def is_multiword(self) -> "bool" : return _freeling.word_is_multiword(self)
    def is_ambiguous_mw(self) -> "bool" : return _freeling.word_is_ambiguous_mw(self)
    def set_ambiguous_mw(self, *args) -> "void" : return _freeling.word_set_ambiguous_mw(self, *args)
    def get_n_words_mw(self) -> "int" : return _freeling.word_get_n_words_mw(self)
    def get_words_mw(self) -> "std::list< freeling::word,std::allocator< freeling::word > > const &" : return _freeling.word_get_words_mw(self)
    def get_form(self) -> "std::wstring" : return _freeling.word_get_form(self)
    def get_lc_form(self) -> "std::wstring" : return _freeling.word_get_lc_form(self)
    def get_ph_form(self) -> "std::wstring" : return _freeling.word_get_ph_form(self)
    def selected_begin(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_selected_begin(self, *args)
    def selected_end(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_selected_end(self, *args)
    def unselected_begin(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_unselected_begin(self, *args)
    def unselected_end(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_unselected_end(self, *args)
    def num_kbest(self) -> "unsigned int" : return _freeling.word_num_kbest(self)
    def get_lemma(self, k : 'int'=0) -> "std::wstring" : return _freeling.word_get_lemma(self, k)
    def get_tag(self, k : 'int'=0) -> "std::wstring" : return _freeling.word_get_tag(self, k)
    def get_senses(self, k : 'int'=0) -> "std::list< std::pair< std::wstring,double >,std::allocator< std::pair< std::wstring,double > > >" : return _freeling.word_get_senses(self, k)
    def get_senses_string(self, k : 'int'=0) -> "std::wstring" : return _freeling.word_get_senses_string(self, k)
    def set_senses(self, *args) -> "void" : return _freeling.word_set_senses(self, *args)
    def get_span_start(self) -> "unsigned long" : return _freeling.word_get_span_start(self)
    def get_span_finish(self) -> "unsigned long" : return _freeling.word_get_span_finish(self)
    def found_in_dict(self) -> "bool" : return _freeling.word_found_in_dict(self)
    def set_found_in_dict(self, *args) -> "void" : return _freeling.word_set_found_in_dict(self, *args)
    def has_retokenizable(self) -> "bool" : return _freeling.word_has_retokenizable(self)
    def lock_analysis(self) -> "void" : return _freeling.word_lock_analysis(self)
    def is_locked(self) -> "bool" : return _freeling.word_is_locked(self)
    def add_alternative(self, *args) -> "void" : return _freeling.word_add_alternative(self, *args)
    def set_alternatives(self, *args) -> "void" : return _freeling.word_set_alternatives(self, *args)
    def clear_alternatives(self) -> "void" : return _freeling.word_clear_alternatives(self)
    def has_alternatives(self) -> "bool" : return _freeling.word_has_alternatives(self)
    def get_alternatives(self, *args) -> "std::list< std::pair< std::wstring,int >,std::allocator< std::pair< std::wstring,int > > > const &" : return _freeling.word_get_alternatives(self, *args)
    def alternatives_begin(self, *args) -> "std::list< std::pair< std::wstring,int >,std::allocator< std::pair< std::wstring,int > > >::const_iterator" : return _freeling.word_alternatives_begin(self, *args)
    def alternatives_end(self, *args) -> "std::list< std::pair< std::wstring,int >,std::allocator< std::pair< std::wstring,int > > >::const_iterator" : return _freeling.word_alternatives_end(self, *args)
    def add_analysis(self, *args) -> "void" : return _freeling.word_add_analysis(self, *args)
    def set_analysis(self, *args) -> "void" : return _freeling.word_set_analysis(self, *args)
    def set_form(self, *args) -> "void" : return _freeling.word_set_form(self, *args)
    def set_ph_form(self, *args) -> "void" : return _freeling.word_set_ph_form(self, *args)
    def set_span(self, *args) -> "void" : return _freeling.word_set_span(self, *args)
    def set_position(self, *args) -> "void" : return _freeling.word_set_position(self, *args)
    def get_position(self) -> "size_t" : return _freeling.word_get_position(self)
    def find_tag_match(self, *args) -> "bool" : return _freeling.word_find_tag_match(self, *args)
    def get_n_analysis(self) -> "int" : return _freeling.word_get_n_analysis(self)
    def unselect_all_analysis(self, k : 'int'=0) -> "void" : return _freeling.word_unselect_all_analysis(self, k)
    def select_all_analysis(self, k : 'int'=0) -> "void" : return _freeling.word_select_all_analysis(self, k)
    def select_analysis(self, *args) -> "void" : return _freeling.word_select_analysis(self, *args)
    def unselect_analysis(self, *args) -> "void" : return _freeling.word_unselect_analysis(self, *args)
    def get_analysis(self) -> "std::list< freeling::analysis,std::allocator< freeling::analysis > >" : return _freeling.word_get_analysis(self)
    def analysis_begin(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_analysis_begin(self, *args)
    def analysis_end(self, *args) -> "freeling::word::const_iterator" : return _freeling.word_analysis_end(self, *args)
word_swigregister = _freeling.word_swigregister
word_swigregister(word)

class node(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, node, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, node, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_node(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_node
    __del__ = lambda self : None;
    def get_node_id(self) -> "std::wstring" : return _freeling.node_get_node_id(self)
    def set_node_id(self, *args) -> "void" : return _freeling.node_set_node_id(self, *args)
    def get_label(self) -> "std::wstring" : return _freeling.node_get_label(self)
    def get_word(self, *args) -> "freeling::word const &" : return _freeling.node_get_word(self, *args)
    def set_label(self, *args) -> "void" : return _freeling.node_set_label(self, *args)
    def set_word(self, *args) -> "void" : return _freeling.node_set_word(self, *args)
    def is_head(self) -> "bool" : return _freeling.node_is_head(self)
    def set_head(self, *args) -> "void" : return _freeling.node_set_head(self, *args)
    def is_chunk(self) -> "bool" : return _freeling.node_is_chunk(self)
    def set_chunk(self, *args) -> "void" : return _freeling.node_set_chunk(self, *args)
    def get_chunk_ord(self) -> "int" : return _freeling.node_get_chunk_ord(self)
node_swigregister = _freeling.node_swigregister
node_swigregister(node)

class parse_tree(TreeNode):
    __swig_setmethods__ = {}
    for _s in [TreeNode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, parse_tree, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeNode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, parse_tree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_parse_tree(*args)
        try: self.this.append(this)
        except: self.this = this
    def build_node_index(self, *args) -> "void" : return _freeling.parse_tree_build_node_index(self, *args)
    def rebuild_node_index(self) -> "void" : return _freeling.parse_tree_rebuild_node_index(self)
    def get_node_by_id(self, *args) -> "freeling::parse_tree::const_iterator" : return _freeling.parse_tree_get_node_by_id(self, *args)
    def get_node_by_pos(self, *args) -> "freeling::parse_tree::const_iterator" : return _freeling.parse_tree_get_node_by_pos(self, *args)
    __swig_destroy__ = _freeling.delete_parse_tree
    __del__ = lambda self : None;
parse_tree_swigregister = _freeling.parse_tree_swigregister
parse_tree_swigregister(parse_tree)

class depnode(node):
    __swig_setmethods__ = {}
    for _s in [node]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, depnode, name, value)
    __swig_getmethods__ = {}
    for _s in [node]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, depnode, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_depnode(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_depnode
    __del__ = lambda self : None;
    def set_link(self, *args) -> "void" : return _freeling.depnode_set_link(self, *args)
    def get_link(self, *args) -> "freeling::parse_tree::const_iterator" : return _freeling.depnode_get_link(self, *args)
    def get_link_ref(self) -> "freeling::tree< freeling::node > &" : return _freeling.depnode_get_link_ref(self)
    def set_label(self, *args) -> "void" : return _freeling.depnode_set_label(self, *args)
depnode_swigregister = _freeling.depnode_swigregister
depnode_swigregister(depnode)

class dep_tree(TreeDepnode):
    __swig_setmethods__ = {}
    for _s in [TreeDepnode]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, dep_tree, name, value)
    __swig_getmethods__ = {}
    for _s in [TreeDepnode]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, dep_tree, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_dep_tree(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_node_by_pos(self, *args) -> "freeling::dep_tree::const_iterator" : return _freeling.dep_tree_get_node_by_pos(self, *args)
    def rebuild_node_index(self) -> "void" : return _freeling.dep_tree_rebuild_node_index(self)
    __swig_destroy__ = _freeling.delete_dep_tree
    __del__ = lambda self : None;
dep_tree_swigregister = _freeling.dep_tree_swigregister
dep_tree_swigregister(dep_tree)

class sentence(ListWord):
    __swig_setmethods__ = {}
    for _s in [ListWord]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, sentence, name, value)
    __swig_getmethods__ = {}
    for _s in [ListWord]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, sentence, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_sentence(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_sentence
    __del__ = lambda self : None;
    def num_kbest(self) -> "unsigned int" : return _freeling.sentence_num_kbest(self)
    def push_back(self, *args) -> "void" : return _freeling.sentence_push_back(self, *args)
    def rebuild_word_index(self) -> "void" : return _freeling.sentence_rebuild_word_index(self)
    def clear(self) -> "void" : return _freeling.sentence_clear(self)
    def set_sentence_id(self, *args) -> "void" : return _freeling.sentence_set_sentence_id(self, *args)
    def get_sentence_id(self) -> "std::wstring" : return _freeling.sentence_get_sentence_id(self)
    def set_parse_tree(self, *args) -> "void" : return _freeling.sentence_set_parse_tree(self, *args)
    def get_parse_tree(self, *args) -> "freeling::parse_tree const &" : return _freeling.sentence_get_parse_tree(self, *args)
    def is_parsed(self) -> "bool" : return _freeling.sentence_is_parsed(self)
    def set_dep_tree(self, *args) -> "void" : return _freeling.sentence_set_dep_tree(self, *args)
    def get_dep_tree(self, *args) -> "freeling::dep_tree const &" : return _freeling.sentence_get_dep_tree(self, *args)
    def is_dep_parsed(self) -> "bool" : return _freeling.sentence_is_dep_parsed(self)
    def get_words(self) -> "std::vector< freeling::word,std::allocator< freeling::word > >" : return _freeling.sentence_get_words(self)
    def words_begin(self, *args) -> "freeling::sentence::const_iterator" : return _freeling.sentence_words_begin(self, *args)
    def words_end(self, *args) -> "freeling::sentence::const_iterator" : return _freeling.sentence_words_end(self, *args)
sentence_swigregister = _freeling.sentence_swigregister
sentence_swigregister(sentence)

class paragraph(ListSentence):
    __swig_setmethods__ = {}
    for _s in [ListSentence]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, paragraph, name, value)
    __swig_getmethods__ = {}
    for _s in [ListSentence]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, paragraph, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _freeling.new_paragraph()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_paragraph
    __del__ = lambda self : None;
paragraph_swigregister = _freeling.paragraph_swigregister
paragraph_swigregister(paragraph)

class document(ListParagraph):
    __swig_setmethods__ = {}
    for _s in [ListParagraph]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, document, name, value)
    __swig_getmethods__ = {}
    for _s in [ListParagraph]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, document, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _freeling.new_document()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_document
    __del__ = lambda self : None;
    def add_positive(self, *args) -> "void" : return _freeling.document_add_positive(self, *args)
    def get_coref_group(self, *args) -> "int" : return _freeling.document_get_coref_group(self, *args)
    def get_coref_nodes(self, *args) -> "std::list< std::wstring,std::allocator< std::wstring > >" : return _freeling.document_get_coref_nodes(self, *args)
    def is_coref(self, *args) -> "bool" : return _freeling.document_is_coref(self, *args)
document_swigregister = _freeling.document_swigregister
document_swigregister(document)

class traces(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, traces, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, traces, name)
    __repr__ = _swig_repr
    __swig_setmethods__["TraceLevel"] = _freeling.traces_TraceLevel_set
    __swig_getmethods__["TraceLevel"] = _freeling.traces_TraceLevel_get
    if _newclass:TraceLevel = _swig_property(_freeling.traces_TraceLevel_get, _freeling.traces_TraceLevel_set)
    __swig_setmethods__["TraceModule"] = _freeling.traces_TraceModule_set
    __swig_getmethods__["TraceModule"] = _freeling.traces_TraceModule_get
    if _newclass:TraceModule = _swig_property(_freeling.traces_TraceModule_get, _freeling.traces_TraceModule_set)
    def __init__(self): 
        this = _freeling.new_traces()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_traces
    __del__ = lambda self : None;
traces_swigregister = _freeling.traces_swigregister
traces_swigregister(traces)
cvar = _freeling.cvar

class lang_ident(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, lang_ident, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, lang_ident, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_lang_ident(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_lang_ident
    __del__ = lambda self : None;
    def add_language(self, *args) -> "void" : return _freeling.lang_ident_add_language(self, *args)
    def train_language(self, *args) -> "void" : return _freeling.lang_ident_train_language(self, *args)
    def identify_language(self, *args) -> "std::wstring" : return _freeling.lang_ident_identify_language(self, *args)
    def rank_languages(self, *args) -> "void" : return _freeling.lang_ident_rank_languages(self, *args)
lang_ident_swigregister = _freeling.lang_ident_swigregister
lang_ident_swigregister(lang_ident)

class tokenizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tokenizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tokenizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_tokenizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_tokenizer
    __del__ = lambda self : None;
    def tokenize(self, *args) -> "std::list< freeling::word,std::allocator< freeling::word > >" : return _freeling.tokenizer_tokenize(self, *args)
tokenizer_swigregister = _freeling.tokenizer_swigregister
tokenizer_swigregister(tokenizer)

class splitter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, splitter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, splitter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_splitter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_splitter
    __del__ = lambda self : None;
    def split(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.splitter_split(self, *args)
splitter_swigregister = _freeling.splitter_swigregister
splitter_swigregister(splitter)

class maco_options(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maco_options, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maco_options, name)
    __repr__ = _swig_repr
    __swig_setmethods__["Lang"] = _freeling.maco_options_Lang_set
    __swig_getmethods__["Lang"] = _freeling.maco_options_Lang_get
    if _newclass:Lang = _swig_property(_freeling.maco_options_Lang_get, _freeling.maco_options_Lang_set)
    __swig_setmethods__["AffixAnalysis"] = _freeling.maco_options_AffixAnalysis_set
    __swig_getmethods__["AffixAnalysis"] = _freeling.maco_options_AffixAnalysis_get
    if _newclass:AffixAnalysis = _swig_property(_freeling.maco_options_AffixAnalysis_get, _freeling.maco_options_AffixAnalysis_set)
    __swig_setmethods__["MultiwordsDetection"] = _freeling.maco_options_MultiwordsDetection_set
    __swig_getmethods__["MultiwordsDetection"] = _freeling.maco_options_MultiwordsDetection_get
    if _newclass:MultiwordsDetection = _swig_property(_freeling.maco_options_MultiwordsDetection_get, _freeling.maco_options_MultiwordsDetection_set)
    __swig_setmethods__["NumbersDetection"] = _freeling.maco_options_NumbersDetection_set
    __swig_getmethods__["NumbersDetection"] = _freeling.maco_options_NumbersDetection_get
    if _newclass:NumbersDetection = _swig_property(_freeling.maco_options_NumbersDetection_get, _freeling.maco_options_NumbersDetection_set)
    __swig_setmethods__["PunctuationDetection"] = _freeling.maco_options_PunctuationDetection_set
    __swig_getmethods__["PunctuationDetection"] = _freeling.maco_options_PunctuationDetection_get
    if _newclass:PunctuationDetection = _swig_property(_freeling.maco_options_PunctuationDetection_get, _freeling.maco_options_PunctuationDetection_set)
    __swig_setmethods__["DatesDetection"] = _freeling.maco_options_DatesDetection_set
    __swig_getmethods__["DatesDetection"] = _freeling.maco_options_DatesDetection_get
    if _newclass:DatesDetection = _swig_property(_freeling.maco_options_DatesDetection_get, _freeling.maco_options_DatesDetection_set)
    __swig_setmethods__["QuantitiesDetection"] = _freeling.maco_options_QuantitiesDetection_set
    __swig_getmethods__["QuantitiesDetection"] = _freeling.maco_options_QuantitiesDetection_get
    if _newclass:QuantitiesDetection = _swig_property(_freeling.maco_options_QuantitiesDetection_get, _freeling.maco_options_QuantitiesDetection_set)
    __swig_setmethods__["DictionarySearch"] = _freeling.maco_options_DictionarySearch_set
    __swig_getmethods__["DictionarySearch"] = _freeling.maco_options_DictionarySearch_get
    if _newclass:DictionarySearch = _swig_property(_freeling.maco_options_DictionarySearch_get, _freeling.maco_options_DictionarySearch_set)
    __swig_setmethods__["ProbabilityAssignment"] = _freeling.maco_options_ProbabilityAssignment_set
    __swig_getmethods__["ProbabilityAssignment"] = _freeling.maco_options_ProbabilityAssignment_get
    if _newclass:ProbabilityAssignment = _swig_property(_freeling.maco_options_ProbabilityAssignment_get, _freeling.maco_options_ProbabilityAssignment_set)
    __swig_setmethods__["UserMap"] = _freeling.maco_options_UserMap_set
    __swig_getmethods__["UserMap"] = _freeling.maco_options_UserMap_get
    if _newclass:UserMap = _swig_property(_freeling.maco_options_UserMap_get, _freeling.maco_options_UserMap_set)
    __swig_setmethods__["NERecognition"] = _freeling.maco_options_NERecognition_set
    __swig_getmethods__["NERecognition"] = _freeling.maco_options_NERecognition_get
    if _newclass:NERecognition = _swig_property(_freeling.maco_options_NERecognition_get, _freeling.maco_options_NERecognition_set)
    __swig_setmethods__["LocutionsFile"] = _freeling.maco_options_LocutionsFile_set
    __swig_getmethods__["LocutionsFile"] = _freeling.maco_options_LocutionsFile_get
    if _newclass:LocutionsFile = _swig_property(_freeling.maco_options_LocutionsFile_get, _freeling.maco_options_LocutionsFile_set)
    __swig_setmethods__["QuantitiesFile"] = _freeling.maco_options_QuantitiesFile_set
    __swig_getmethods__["QuantitiesFile"] = _freeling.maco_options_QuantitiesFile_get
    if _newclass:QuantitiesFile = _swig_property(_freeling.maco_options_QuantitiesFile_get, _freeling.maco_options_QuantitiesFile_set)
    __swig_setmethods__["AffixFile"] = _freeling.maco_options_AffixFile_set
    __swig_getmethods__["AffixFile"] = _freeling.maco_options_AffixFile_get
    if _newclass:AffixFile = _swig_property(_freeling.maco_options_AffixFile_get, _freeling.maco_options_AffixFile_set)
    __swig_setmethods__["ProbabilityFile"] = _freeling.maco_options_ProbabilityFile_set
    __swig_getmethods__["ProbabilityFile"] = _freeling.maco_options_ProbabilityFile_get
    if _newclass:ProbabilityFile = _swig_property(_freeling.maco_options_ProbabilityFile_get, _freeling.maco_options_ProbabilityFile_set)
    __swig_setmethods__["DictionaryFile"] = _freeling.maco_options_DictionaryFile_set
    __swig_getmethods__["DictionaryFile"] = _freeling.maco_options_DictionaryFile_get
    if _newclass:DictionaryFile = _swig_property(_freeling.maco_options_DictionaryFile_get, _freeling.maco_options_DictionaryFile_set)
    __swig_setmethods__["NPdataFile"] = _freeling.maco_options_NPdataFile_set
    __swig_getmethods__["NPdataFile"] = _freeling.maco_options_NPdataFile_get
    if _newclass:NPdataFile = _swig_property(_freeling.maco_options_NPdataFile_get, _freeling.maco_options_NPdataFile_set)
    __swig_setmethods__["PunctuationFile"] = _freeling.maco_options_PunctuationFile_set
    __swig_getmethods__["PunctuationFile"] = _freeling.maco_options_PunctuationFile_get
    if _newclass:PunctuationFile = _swig_property(_freeling.maco_options_PunctuationFile_get, _freeling.maco_options_PunctuationFile_set)
    __swig_setmethods__["UserMapFile"] = _freeling.maco_options_UserMapFile_set
    __swig_getmethods__["UserMapFile"] = _freeling.maco_options_UserMapFile_get
    if _newclass:UserMapFile = _swig_property(_freeling.maco_options_UserMapFile_get, _freeling.maco_options_UserMapFile_set)
    __swig_setmethods__["Decimal"] = _freeling.maco_options_Decimal_set
    __swig_getmethods__["Decimal"] = _freeling.maco_options_Decimal_get
    if _newclass:Decimal = _swig_property(_freeling.maco_options_Decimal_get, _freeling.maco_options_Decimal_set)
    __swig_setmethods__["Thousand"] = _freeling.maco_options_Thousand_set
    __swig_getmethods__["Thousand"] = _freeling.maco_options_Thousand_get
    if _newclass:Thousand = _swig_property(_freeling.maco_options_Thousand_get, _freeling.maco_options_Thousand_set)
    __swig_setmethods__["ProbabilityThreshold"] = _freeling.maco_options_ProbabilityThreshold_set
    __swig_getmethods__["ProbabilityThreshold"] = _freeling.maco_options_ProbabilityThreshold_get
    if _newclass:ProbabilityThreshold = _swig_property(_freeling.maco_options_ProbabilityThreshold_get, _freeling.maco_options_ProbabilityThreshold_set)
    __swig_setmethods__["InverseDict"] = _freeling.maco_options_InverseDict_set
    __swig_getmethods__["InverseDict"] = _freeling.maco_options_InverseDict_get
    if _newclass:InverseDict = _swig_property(_freeling.maco_options_InverseDict_get, _freeling.maco_options_InverseDict_set)
    __swig_setmethods__["RetokContractions"] = _freeling.maco_options_RetokContractions_set
    __swig_getmethods__["RetokContractions"] = _freeling.maco_options_RetokContractions_get
    if _newclass:RetokContractions = _swig_property(_freeling.maco_options_RetokContractions_get, _freeling.maco_options_RetokContractions_set)
    def __init__(self, *args): 
        this = _freeling.new_maco_options(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_maco_options
    __del__ = lambda self : None;
    def set_active_modules(self, *args) -> "void" : return _freeling.maco_options_set_active_modules(self, *args)
    def set_data_files(self, *args) -> "void" : return _freeling.maco_options_set_data_files(self, *args)
    def set_nummerical_points(self, *args) -> "void" : return _freeling.maco_options_set_nummerical_points(self, *args)
    def set_threshold(self, *args) -> "void" : return _freeling.maco_options_set_threshold(self, *args)
    def set_inverse_dict(self, *args) -> "void" : return _freeling.maco_options_set_inverse_dict(self, *args)
    def set_retok_contractions(self, *args) -> "void" : return _freeling.maco_options_set_retok_contractions(self, *args)
maco_options_swigregister = _freeling.maco_options_swigregister
maco_options_swigregister(maco_options)

class maco(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, maco, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, maco, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_maco(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_maco
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.maco_analyze(self, *args)
maco_swigregister = _freeling.maco_swigregister
maco_swigregister(maco)

class RE_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RE_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RE_map, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_RE_map(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_RE_map
    __del__ = lambda self : None;
    def annotate_word(self, *args) -> "void" : return _freeling.RE_map_annotate_word(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.RE_map_analyze(self, *args)
RE_map_swigregister = _freeling.RE_map_swigregister
RE_map_swigregister(RE_map)

class numbers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, numbers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, numbers, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_numbers(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_numbers
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.numbers_analyze(self, *args)
numbers_swigregister = _freeling.numbers_swigregister
numbers_swigregister(numbers)

class punts(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, punts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, punts, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_punts(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_punts
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.punts_analyze(self, *args)
punts_swigregister = _freeling.punts_swigregister
punts_swigregister(punts)

class dates(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dates, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dates, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_dates(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_dates
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.dates_analyze(self, *args)
dates_swigregister = _freeling.dates_swigregister
dates_swigregister(dates)

class dictionary(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dictionary, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dictionary, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_dictionary(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_dictionary
    __del__ = lambda self : None;
    def add_analysis(self, *args) -> "void" : return _freeling.dictionary_add_analysis(self, *args)
    def remove_entry(self, *args) -> "void" : return _freeling.dictionary_remove_entry(self, *args)
    def search_form(self, *args) -> "void" : return _freeling.dictionary_search_form(self, *args)
    def annotate_word(self, *args) -> "void" : return _freeling.dictionary_annotate_word(self, *args)
    def get_forms(self, *args) -> "std::list< std::wstring,std::allocator< std::wstring > >" : return _freeling.dictionary_get_forms(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.dictionary_analyze(self, *args)
dictionary_swigregister = _freeling.dictionary_swigregister
dictionary_swigregister(dictionary)

class locutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, locutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, locutions, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_locutions(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_locutions
    __del__ = lambda self : None;
    def add_locution(self, *args) -> "void" : return _freeling.locutions_add_locution(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.locutions_analyze(self, *args)
locutions_swigregister = _freeling.locutions_swigregister
locutions_swigregister(locutions)

class ner(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ner, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ner, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ner(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ner
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.ner_analyze(self, *args)
ner_swigregister = _freeling.ner_swigregister
ner_swigregister(ner)

class quantities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, quantities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, quantities, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_quantities(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_quantities
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.quantities_analyze(self, *args)
quantities_swigregister = _freeling.quantities_swigregister
quantities_swigregister(quantities)

class probabilities(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, probabilities, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, probabilities, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_probabilities(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_probabilities
    __del__ = lambda self : None;
    def annotate_word(self, *args) -> "void" : return _freeling.probabilities_annotate_word(self, *args)
    def set_activate_guesser(self, *args) -> "void" : return _freeling.probabilities_set_activate_guesser(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.probabilities_analyze(self, *args)
probabilities_swigregister = _freeling.probabilities_swigregister
probabilities_swigregister(probabilities)

class hmm_tagger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, hmm_tagger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, hmm_tagger, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_hmm_tagger(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_hmm_tagger
    __del__ = lambda self : None;
    def SequenceProb_log(self, *args) -> "double" : return _freeling.hmm_tagger_SequenceProb_log(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.hmm_tagger_analyze(self, *args)
hmm_tagger_swigregister = _freeling.hmm_tagger_swigregister
hmm_tagger_swigregister(hmm_tagger)

class relax_tagger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, relax_tagger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, relax_tagger, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_relax_tagger(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_relax_tagger
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.relax_tagger_analyze(self, *args)
relax_tagger_swigregister = _freeling.relax_tagger_swigregister
relax_tagger_swigregister(relax_tagger)

class alternatives(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, alternatives, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, alternatives, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_alternatives(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_alternatives
    __del__ = lambda self : None;
    def get_similar_words(self, *args) -> "void" : return _freeling.alternatives_get_similar_words(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.alternatives_analyze(self, *args)
alternatives_swigregister = _freeling.alternatives_swigregister
alternatives_swigregister(alternatives)

class phonetics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, phonetics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, phonetics, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_phonetics(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_phonetics
    __del__ = lambda self : None;
    def get_sound(self, *args) -> "std::wstring" : return _freeling.phonetics_get_sound(self, *args)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.phonetics_analyze(self, *args)
phonetics_swigregister = _freeling.phonetics_swigregister
phonetics_swigregister(phonetics)

class nec(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, nec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, nec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_nec(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_nec
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.nec_analyze(self, *args)
nec_swigregister = _freeling.nec_swigregister
nec_swigregister(nec)

class chart_parser(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, chart_parser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, chart_parser, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_chart_parser(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_chart_parser
    __del__ = lambda self : None;
    def get_start_symbol(self) -> "std::wstring" : return _freeling.chart_parser_get_start_symbol(self)
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.chart_parser_analyze(self, *args)
chart_parser_swigregister = _freeling.chart_parser_swigregister
chart_parser_swigregister(chart_parser)

class dep_txala(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, dep_txala, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, dep_txala, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_dep_txala(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_dep_txala
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.dep_txala_analyze(self, *args)
dep_txala_swigregister = _freeling.dep_txala_swigregister
dep_txala_swigregister(dep_txala)

class senses(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, senses, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, senses, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_senses(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_senses
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.senses_analyze(self, *args)
senses_swigregister = _freeling.senses_swigregister
senses_swigregister(senses)

class ukb(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ukb, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ukb, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_ukb(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_ukb
    __del__ = lambda self : None;
    def analyze(self, *args) -> "std::list< freeling::sentence,std::allocator< freeling::sentence > >" : return _freeling.ukb_analyze(self, *args)
ukb_swigregister = _freeling.ukb_swigregister
ukb_swigregister(ukb)

class sense_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, sense_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, sense_info, name)
    __repr__ = _swig_repr
    __swig_setmethods__["sense"] = _freeling.sense_info_sense_set
    __swig_getmethods__["sense"] = _freeling.sense_info_sense_get
    if _newclass:sense = _swig_property(_freeling.sense_info_sense_get, _freeling.sense_info_sense_set)
    __swig_setmethods__["parents"] = _freeling.sense_info_parents_set
    __swig_getmethods__["parents"] = _freeling.sense_info_parents_get
    if _newclass:parents = _swig_property(_freeling.sense_info_parents_get, _freeling.sense_info_parents_set)
    __swig_setmethods__["semfile"] = _freeling.sense_info_semfile_set
    __swig_getmethods__["semfile"] = _freeling.sense_info_semfile_get
    if _newclass:semfile = _swig_property(_freeling.sense_info_semfile_get, _freeling.sense_info_semfile_set)
    __swig_setmethods__["words"] = _freeling.sense_info_words_set
    __swig_getmethods__["words"] = _freeling.sense_info_words_get
    if _newclass:words = _swig_property(_freeling.sense_info_words_get, _freeling.sense_info_words_set)
    __swig_setmethods__["tonto"] = _freeling.sense_info_tonto_set
    __swig_getmethods__["tonto"] = _freeling.sense_info_tonto_get
    if _newclass:tonto = _swig_property(_freeling.sense_info_tonto_get, _freeling.sense_info_tonto_set)
    def __init__(self, *args): 
        this = _freeling.new_sense_info(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_parents_string(self) -> "std::wstring" : return _freeling.sense_info_get_parents_string(self)
    __swig_destroy__ = _freeling.delete_sense_info
    __del__ = lambda self : None;
sense_info_swigregister = _freeling.sense_info_swigregister
sense_info_swigregister(sense_info)

class semanticDB(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, semanticDB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, semanticDB, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_semanticDB(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_semanticDB
    __del__ = lambda self : None;
    def get_WN_keys(self, *args) -> "void" : return _freeling.semanticDB_get_WN_keys(self, *args)
    def get_sense_words(self, *args) -> "std::list< std::wstring,std::allocator< std::wstring > >" : return _freeling.semanticDB_get_sense_words(self, *args)
    def get_word_senses(self, *args) -> "std::list< std::wstring,std::allocator< std::wstring > >" : return _freeling.semanticDB_get_word_senses(self, *args)
    def get_sense_info(self, *args) -> "freeling::sense_info" : return _freeling.semanticDB_get_sense_info(self, *args)
semanticDB_swigregister = _freeling.semanticDB_swigregister
semanticDB_swigregister(semanticDB)

class tagset(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tagset, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tagset, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_tagset(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_tagset
    __del__ = lambda self : None;
    def get_short_tag(self, *args) -> "std::wstring" : return _freeling.tagset_get_short_tag(self, *args)
    def get_msf_features(self, *args) -> "std::list< std::pair< std::wstring,std::wstring >,std::allocator< std::pair< std::wstring,std::wstring > > >" : return _freeling.tagset_get_msf_features(self, *args)
    def get_msf_string(self, *args) -> "std::wstring" : return _freeling.tagset_get_msf_string(self, *args)
tagset_swigregister = _freeling.tagset_swigregister
tagset_swigregister(tagset)

class foma_FSM(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, foma_FSM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, foma_FSM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _freeling.new_foma_FSM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_foma_FSM
    __del__ = lambda self : None;
    def get_similar_words(self, *args) -> "void" : return _freeling.foma_FSM_get_similar_words(self, *args)
    def set_cutoff_threshold(self, *args) -> "void" : return _freeling.foma_FSM_set_cutoff_threshold(self, *args)
    def set_num_matches(self, *args) -> "void" : return _freeling.foma_FSM_set_num_matches(self, *args)
    def set_basic_operation_cost(self, *args) -> "void" : return _freeling.foma_FSM_set_basic_operation_cost(self, *args)
foma_FSM_swigregister = _freeling.foma_FSM_swigregister
foma_FSM_swigregister(foma_FSM)

class util(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, util, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, util, name)
    __repr__ = _swig_repr
    __swig_getmethods__["init_locale"] = lambda x: _freeling.util_init_locale
    if _newclass:init_locale = staticmethod(_freeling.util_init_locale)
    __swig_getmethods__["wstring2int"] = lambda x: _freeling.util_wstring2int
    if _newclass:wstring2int = staticmethod(_freeling.util_wstring2int)
    __swig_getmethods__["int2wstring"] = lambda x: _freeling.util_int2wstring
    if _newclass:int2wstring = staticmethod(_freeling.util_int2wstring)
    __swig_getmethods__["wstring2double"] = lambda x: _freeling.util_wstring2double
    if _newclass:wstring2double = staticmethod(_freeling.util_wstring2double)
    __swig_getmethods__["double2wstring"] = lambda x: _freeling.util_double2wstring
    if _newclass:double2wstring = staticmethod(_freeling.util_double2wstring)
    __swig_getmethods__["wstring2longdouble"] = lambda x: _freeling.util_wstring2longdouble
    if _newclass:wstring2longdouble = staticmethod(_freeling.util_wstring2longdouble)
    __swig_getmethods__["longdouble2wstring"] = lambda x: _freeling.util_longdouble2wstring
    if _newclass:longdouble2wstring = staticmethod(_freeling.util_longdouble2wstring)
    __swig_getmethods__["vector2wstring"] = lambda x: _freeling.util_vector2wstring
    if _newclass:vector2wstring = staticmethod(_freeling.util_vector2wstring)
    __swig_getmethods__["list2wstring"] = lambda x: _freeling.util_list2wstring
    if _newclass:list2wstring = staticmethod(_freeling.util_list2wstring)
    __swig_getmethods__["pairlist2wstring"] = lambda x: _freeling.util_pairlist2wstring
    if _newclass:pairlist2wstring = staticmethod(_freeling.util_pairlist2wstring)
    __swig_getmethods__["wstring2list"] = lambda x: _freeling.util_wstring2list
    if _newclass:wstring2list = staticmethod(_freeling.util_wstring2list)
    __swig_getmethods__["wstring2vector"] = lambda x: _freeling.util_wstring2vector
    if _newclass:wstring2vector = staticmethod(_freeling.util_wstring2vector)
    def __init__(self): 
        this = _freeling.new_util()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _freeling.delete_util
    __del__ = lambda self : None;
util_swigregister = _freeling.util_swigregister
util_swigregister(util)

def util_init_locale(*args) -> "void" :
  return _freeling.util_init_locale(*args)
util_init_locale = _freeling.util_init_locale

def util_wstring2int(*args) -> "int" :
  return _freeling.util_wstring2int(*args)
util_wstring2int = _freeling.util_wstring2int

def util_int2wstring(*args) -> "std::wstring" :
  return _freeling.util_int2wstring(*args)
util_int2wstring = _freeling.util_int2wstring

def util_wstring2double(*args) -> "double" :
  return _freeling.util_wstring2double(*args)
util_wstring2double = _freeling.util_wstring2double

def util_double2wstring(*args) -> "std::wstring" :
  return _freeling.util_double2wstring(*args)
util_double2wstring = _freeling.util_double2wstring

def util_wstring2longdouble(*args) -> "long double" :
  return _freeling.util_wstring2longdouble(*args)
util_wstring2longdouble = _freeling.util_wstring2longdouble

def util_longdouble2wstring(*args) -> "std::wstring" :
  return _freeling.util_longdouble2wstring(*args)
util_longdouble2wstring = _freeling.util_longdouble2wstring

def util_vector2wstring(*args) -> "std::wstring" :
  return _freeling.util_vector2wstring(*args)
util_vector2wstring = _freeling.util_vector2wstring

def util_list2wstring(*args) -> "std::wstring" :
  return _freeling.util_list2wstring(*args)
util_list2wstring = _freeling.util_list2wstring

def util_pairlist2wstring(*args) -> "std::wstring" :
  return _freeling.util_pairlist2wstring(*args)
util_pairlist2wstring = _freeling.util_pairlist2wstring

def util_wstring2list(*args) -> "std::list< std::wstring,std::allocator< std::wstring > >" :
  return _freeling.util_wstring2list(*args)
util_wstring2list = _freeling.util_wstring2list

def util_wstring2vector(*args) -> "std::vector< std::wstring,std::allocator< std::wstring > >" :
  return _freeling.util_wstring2vector(*args)
util_wstring2vector = _freeling.util_wstring2vector

# This file is compatible with both classic and new-style classes.


